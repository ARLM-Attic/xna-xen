
//This shader is compiled using a visual studio CustomTool plugin
//(if you view the project properties for this file, the 'Custom Tool' field should be set)
//Make sure you have installed the custom tool plugin, it can be installed with the 
//'registerFX' batch file in the project root.
//(Make sure visual studio is closed when the tool is registered)

//The plugin compiles shaders, and generates a .net class to access them.

//The shader compiler will generate a class for each Technique in this .fx file. 
//These classes all implement the IShader interface.
//The compiling is done at compile time, or whenever the file is saved.
//Shader compile errors will appear in the Error List, just like regular code compile errors.

//For example,
//uncomment the next line, then save the file with ctrl-S.

//float test = undefinedValue;

//The shader compile should fail, showing the following error in the visual studio Error List:
//Custom tool warning: (18): error X3004: undeclared identifier 'undefinedValue'
//This indicates the custom tool has failed on line 18.
//In this case, 'undefinedValue' is not a known value, the DirectX shader compiler can't find it.
//re-comment the line, save, and the file should compile correctly.


//In the solution explorer (project file view), shader.fx should have a '+' box to the left.
//expand it, and it should show an attached file 'shader.fx.cs'.
//This is the code generated by the custom tool.

//Note this shader code file is part of the main project, it is NOT part of the Content project
//The shader byte-code is compressed and embedded into the generated class file, and will be
//part of the compiled .exe/.dll.
//A game does not need to worry about shader content being included in the project correctly.


//There are a few restirctions on what can be used in a shader compiled with the plugin,
//The largest restriction is that Techniques may not make changes to render state.
//This is a design decision (It could be supported with considerable effort and slower compiles).
//The choice was intentional not to support render state changes. While at first it may seem
//useful, in larger projects having shaders changing render state can cause a *lot* of very
//subtle bugs that can be very difficult to fix.
//An IShader instance is intended to only change shader state, not render state.
//By extension of this restiction, multi-pass shaders are not supported by the plugin.
//Although, there is one exception. Texture sampler states may be set by the shader.
//This is because texture sample state changes the shader ouput, whereas render state does not.
//(The default texture sampler mode is always bilinear filtering)




//... on to the example shader


float4x4 worldViewProj : WORLDVIEWPROJECTION;


//Here, the world*view*projection matrix is declared.
//Unlike in Xna Effect files, the Semantic is very important.
//In this case, the semantic is 'WORLDVIEWPROJECTION'.
//The class that is generated will automatically set this to the world*view*projection matrix.
//The generated class does not let you set the constant manually.
//(shader re-binding is not required when the world matrix changes, this case is detecetd.)

//There is a large list of semantics avaliable for shader constants.
//Any combination of WORLD, VIEW and PROJECTION can be used (although only in that order).
//These can also have 'TRANSPOSE' or 'INVERSE' on the end.
//So WORLDTRANSPOSE, VIEWPROJECTION and PROJECTIONINVERSE are all valid.
//VIEWWORLD or WORLDINVERSEVIEW, etc, are not valid - because they are in the wrong order.
//All matrix semantic-bound constants should be declared as matrices (float4x4).

//There are also some non-matrix constants available. These must be declared as the type shown.

//float2 windowSize		: WINDOWSIZE;		// pixel size of the current draw target
//float2 cameraFov		: CAMERAFOV;		// horizontal and vertical fov
//float2 cameraFovTan	: CAMERAFOVTANGENT;
//float2 cameraNearFar	: CAMERANEARFAR;
//float3 viewPoint		: VIEWPOINT;		// position of the camera
//float3 viewDirection	: VIEWDIRECTION;

//viewPoint and viewDirection may also be declared as float4.

float4 colour : GLOBAL;

//In this case, a special semantic is used.
//GLOBAL can be applied to any type except a sampler.
//The DrawState object keeps lists of every global shader constant.
//Global values are application-wide.
//It is intended that globals are set infrequently, or once per frame.
//Globals are not designed to be set every time an object is drawn.
//Set a global with the DrawState object, call the 'SetShaderGlobal("name", value)' method.
//Note that 'texture' and 'texture2D/3D/Cube' are considered different types when using globals.


//finally, a constant without a semantic:

float scale = 1;


//These constants are known as attributes. They are designed to be set frequently.
//In this case, the default value is set to 1.

//If the value is used by the technique, a set-only property 'Vector3 Scale' will be created in
//the generated class. A method 'SetScale(ref Vector3)' will also be created - and is the
//preferred method for setting the value.
//There are no methods generated for getting the value back. This would add considerable overhead.


//Sometimes an attribute must be set through an IShader interface - where the class type is unknown.
//For performance reasons, you cannot set an attribute by string name. The overhead would be too high.
//All attribute names have a unique interger ID.
//The DrawState object can get a unique ID using 'GetShaderAttributeNameUniqueID("name")'.
//This ID will never change for the entire life of the application.
//Every shader instance will implement 'SetAttribute(...)' methods, which will return true if the
//attribute was set correctly.



//Every generated shader class will have a static property called 'Instance'.
//This is a static instance of the shader. This is useful with simpler shaders, allowing for efficient
//reuse of the same shader instance throughout the application.
//Shaders are quite memory and CPU efficient, so reusing them is encouraged.
//Creating an instance per use will add memory overhead - the CPU overhead difference will be fairly small.

//The shader generated by this file will use around 128 bytes per instance.
//Most of this is the 64bytes for the WorldViewProjection matrix.
//It will use around 48 static bytes, one static instance and around 140 bytes for the embedded shader code.
//More complex shaders use more memory.


//Finally, compiler hints can be provided to the custom tool. 
//This can be done by setting the very first line of a shader .fx file to a special comment.
//For example, set the very first line of this file to:

//CompilerOptions = InternalClass

//And the generated shader class will be an internal class, not accessible outside the project.
//The following options are supported:
//CompilerOptions = NoPreShader, InternalClass, AvoidFlowControl, PreferFlowControl, PartialPrecision, DefinePlatform
//The compiler hint will only be detected on the very first line of the file.

//If your shader requires XBOX specific logic, then use the 'DefinePlatform' compiler option.
//When used, the shader will be defined for each platform.
//(the shader will be generated once for windows and once for xbox).
//The macro 'XBOX' or 'XBOX360' will be defined, allowing:
//
//#ifdef XBOX360
//...
//#else
//...
//#endif
//
//



//That is the basics of the shader system covered.
//The rest of the code in this file implements the example shader logic.
//See the game code file for examples of setting the global colour, binding the static instance, and
//setting the attribute value.


//--------------------------------------------------------------//
// vertex shader, scales the mesh by the scale attribute
//--------------------------------------------------------------//
void Tutorial03VS(	
					float4 position			: POSITION, 
				out float4 positionOut		: POSITION)
{
	position.xyz *= scale;
	
	positionOut = mul(position,worldViewProj);
}


//--------------------------------------------------------------//
// pixel shader, returns the global colour
//--------------------------------------------------------------//
float4 Tutorial03PS() : COLOR 
{
	return colour;
}



//--------------------------------------------------------------//
// Technique that uses the shaders
//--------------------------------------------------------------//
technique Tutorial03Technique
{
   pass
   {
		VertexShader = compile vs_2_0 Tutorial03VS();
		PixelShader = compile ps_2_0 Tutorial03PS();
   }
}